{
  "version": 3,
  "sources": ["../../src/config.ts"],
  "sourcesContent": ["import { FromSchema, JSONSchema } from \"json-schema-to-ts\";\nimport { ZilchNamespace } from \"zilch-game-engine\";\n\n/**\n * User facing config schema\n */\ntype RawConfig = FromSchema<typeof configSchema>;\n\nexport interface Config {\n  initialBoard: (number | null)[][];\n  initialTurn: number;\n}\n\nexport interface State {\n  board: (number | [number, number] | null)[][];\n}\n\ndeclare global {\n  const Zilch: ZilchNamespace<RawConfig, Config, State>;\n}\n\n/**\n * Schema for the JSON users can input as part of\n * game setup.\n */\nconst configSchema = {\n  type: \"object\",\n  required: [\"startingPosition\"],\n  properties: {\n    startingPosition: {\n      description: \"The best description that ever there was.\",\n      type: \"array\",\n      minItems: 3,\n      maxItems: 3,\n      items: {\n        type: \"array\",\n        minItems: 3,\n        maxItems: 3,\n        items: {\n          type: [\"string\"],\n          enum: [\"x\", \"o\", \"empty\"],\n        },\n      },\n    },\n  },\n} as const satisfies JSONSchema;\nZilch.configSchema = configSchema;\n\nZilch.configPresets = [\n  {\n    name: \"Standard\",\n    value:\n      `{\\n` +\n      `  // 3x3 matrix with values \"x\", \"o\" and \"empty\"\\n` +\n      `  \"startingPosition\": [\\n` +\n      `    [\"empty\", \"empty\", \"empty\"],\\n` +\n      `    [\"empty\", \"empty\", \"empty\"],\\n` +\n      `    [\"empty\", \"empty\", \"empty\"]\\n` +\n      `  ]\\n` +\n      `}\\n`,\n  },\n];\n\nZilch.parseConfig = (rawConfig) => {\n  let xCount = 0;\n  let oCount = 0;\n\n  const initialBoard = rawConfig.startingPosition.map((row) => {\n    return row.map((spot) => {\n      if (spot === \"x\") {\n        return xCount++ * 2;\n      } else if (spot === \"o\") {\n        return oCount++ * 2 + 1;\n      } else {\n        return null;\n      }\n    });\n  });\n\n  if (xCount - oCount !== 0 && xCount - oCount !== 1) {\n    throw new Error(\n      \"There should be an even number of Xs and Os (or just one more X than O) in the starting position.\"\n    );\n  }\n\n  return {\n    initialBoard,\n    initialTurn: oCount + xCount,\n  };\n};\n\nZilch.serializeConfig = (config) => {\n  const board = config.initialBoard.map((row) => {\n    return row.map((spot) => {\n      if (spot === null) {\n        return \"empty\";\n      } else {\n        return spot % 2 === 0 ? \"x\" : \"o\";\n      }\n    });\n  });\n\n  return board.map((row) => row.join(\",\")).join(\"|\");\n};\n\nZilch.summarizeConfig = (config) => {\n  if (config.initialTurn === 0) {\n    return \"standard starting position\";\n  } else {\n    return \"custom starting position\";\n  }\n};\n"],
  "mappings": "AAyBA,IAAMA,EAAe,CACnB,KAAM,SACN,SAAU,CAAC,kBAAkB,EAC7B,WAAY,CACV,iBAAkB,CAChB,YAAa,4CACb,KAAM,QACN,SAAU,EACV,SAAU,EACV,MAAO,CACL,KAAM,QACN,SAAU,EACV,SAAU,EACV,MAAO,CACL,KAAM,CAAC,QAAQ,EACf,KAAM,CAAC,IAAK,IAAK,OAAO,CAC1B,CACF,CACF,CACF,CACF,EACA,MAAM,aAAeA,EAErB,MAAM,cAAgB,CACpB,CACE,KAAM,WACN,MACE;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,CAQJ,CACF,EAEA,MAAM,YAAeC,GAAc,CACjC,IAAIC,EAAS,EACTC,EAAS,EAEPC,EAAeH,EAAU,iBAAiB,IAAKI,GAC5CA,EAAI,IAAKC,GACVA,IAAS,IACJJ,IAAW,EACTI,IAAS,IACXH,IAAW,EAAI,EAEf,IAEV,CACF,EAED,GAAID,EAASC,IAAW,GAAKD,EAASC,IAAW,EAC/C,MAAM,IAAI,MACR,mGACF,EAGF,MAAO,CACL,aAAAC,EACA,YAAaD,EAASD,CACxB,CACF,EAEA,MAAM,gBAAmBK,GACTA,EAAO,aAAa,IAAKF,GAC9BA,EAAI,IAAKC,GACVA,IAAS,KACJ,QAEAA,EAAO,IAAM,EAAI,IAAM,GAEjC,CACF,EAEY,IAAKD,GAAQA,EAAI,KAAK,GAAG,CAAC,EAAE,KAAK,GAAG,EAGnD,MAAM,gBAAmBE,GACnBA,EAAO,cAAgB,EAClB,6BAEA",
  "names": ["configSchema", "rawConfig", "xCount", "oCount", "initialBoard", "row", "spot", "config"]
}
